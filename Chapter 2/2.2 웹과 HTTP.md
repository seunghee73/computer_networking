## 2.2 웹과 HTTP

### 2.2.1 HTTP 개요

* HTTP(HyperText Transfer Protocol)는 웹의 애플리케이션 계층 프로토콜이자 웹의 중심

* 클라이언트 프로그램과 서버 프로그램으로 구현

  * 두 프로그램은 서로 HTTP 메시지를 교환하여 통신
  
* 웹 페이지(web page)는 객체들로 구성되고 객체는 단순히 단일 URL로 지정할 수 있는 하나의 파일(HTML파일, JPEG 이미지, GIF 이미지 등)이다.

* 웹 브라우저는 HTTP의 클라이언트 측을 구현하기 때문에 웹의 관점에서 브라우저와 클라이언트라는 용어가 혼용되어 사용된다.

* 웹 서버는 URL로 각각 지정할 수 있는 웹 객체를 갖고 있다.

* HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다.

  * 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에 보낸다.
  
  * 서버는 요청을 수신하고, 객체를 포함하는 HTTP 응답 메시지로 응답한다.
  
* HTTP는 TCP를 전송 프로토콜로 사용

* HTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로, 비상태 프로토콜 (stateless protocol)이라고 한다.

### 2.2.2 비지속 연결과 지속 연결

* 비지속 연결(non-persistent connection) : 각 요구/응답 쌍이 분리된 TCP 연결을 통해 보내지는 연결

* 지속 연결(persistent connection) : 모든 요구와 해당하는 응답들이 같은 TCP 연결상으로 보내지는 연결

* 비지속 연결 HTTP

  * 연결 수행 과정

    1. HTTP 클라이언트는 HTTP의 기본 포트 번호 80을 통해 서버로 TCP 연결 시도, TCP 연결과 관련하여 클라이언트와 서버에 각각 소켓이 있게 된다

    2. HTTP 클라이언트는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 연결 요청을 보낸다.
    
    3. HTTP 서버는 1단계에서 설정된 연결 소켓을 통해 요청 메시지를 받는다. HTTP 응답 메시지에 그 객체를 갭슐화하고 소켓을 통해 보낸다.
    
    4. HTTP 서버는 TCP에게 TCP 연결을 끊으라고 하지만 실제로 클라이언트가 응답 메시지를 올바로 받을 때까지 연결을 끊지 않는다.
    
    5. HTTP 클라이언트가 응답 메시지를 받으면 TCP 연결이 중단된다.
    
    6. 해당 과정을 모든 파일을 받을 때까지 반복된다.

  * RTT(round trip time) : 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는데 걸리는 시간

    * 패킷 전파 지연, 중간 라우터와 스위치에서의 패킷 큐잉 지연, 패킷 처리 지연 등을 포함

  * 세 방향 핸드 셰이크

    * 클라이언트가 작은 TCP 메시지를 서버로 보낸다.

    * 서버는 작은 메시지로 응답한다.

      (위 두 과정에서 RTT가 계산이 된다)

    * 마지막으로 클라이언트가 다시 응답한다. (HTTP 요청 메시지를 TCP 연결로 보내면서 이 부분에 대한 응답을 함께 보낸다)

  * 단점 : 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다, 각 객체는 2 RTT를 필요로 한다(TCP 연결에 1 RTT, 객체를 요청하고 받는데 1 RTT)

* 지속 연결 HTTP

  * 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다.
  
  * 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있다. (파이프라이닝, pipelining)
  
  * HTTP 서버는 일정 기간(타임아웃 기간) 사용되지 않으면 연결을 닫는다.
  
* HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결을 사용

### 2.2.3 HTTP 메시지 포맷

* HTTP 요청 메시지

```
GET/somedir/page.html HTTP/1.1
Host : www.someschool.edu
Connection : close
User-agent : Mozilla/5.0
Accept-language : fr
```
  메시지가 일반적인 ASCII 텍스트로 쓰여있어 많은 사람들이 읽을 수 있다.

  메시지가 다섯 줄로 되어 있고 각 줄은 CR(carriage return, 맨 앞으로 이동), LF(lin feed, `\n`)로 구별

  HTTP 요청 메시지의 첫 줄은 요청 라인(request line)이라 부르고 이 후 줄은 헤더 라인(header line)이라고 부른다.

  요청 라인은 3개의 필드(메소드 필드, URL 필드, HTTP버전 필드)를 갖는다.

  헤더라인 `Host : www.someschool.edu`는 객체가 존재하는 호스트를 명시하고 있다.

  `Connection : close` 를 통해 브라우저는 서버에게 지속 연결 사용을 원하지 않는다는 것을 알 수 있다.

  `User-agent` 헤더라인은 사용자 에이전트, 서버에게 요청을 하는 브라우저의 타입을 명시하고 있다

  `Accept-language` 헤더는 사용자가 객체의 프랑스어 버전을 원하고 있음을 나타낸다. 존재하지 않는 경우 기본 버전을 보낸다.

* 요청 메시지의 일반 포맷에는 헤더라인 뒤에 개체 몸체(entity body)가 존재한다.

  * GET 방식에서는 비어있고 POST 방식에 사용된다.
  
  * 클라이언트는 사용자가 폼을 채워 놓을 때 POST 방식을 사용하고, 개체 몸체에는 사용자가 폼 필드에 입력한 내용을 포함한다.

* HTTP 응답 메시지

```
HTTP/1.1 200 OK
Connection : close
Date : Tue, 18 Aug 2015 15:44:04 GMT
Server : Apache/2.2.3 (CentOS)
Last-Modified : Tue, 18 Aug 2015 15:11:03 GMT
Content-Length : 6821
Content-Type : text/html
(데이터 데이터 데이터 데이터 ...)
```

  초기 상태 라인, 6개의 헤더라인, 개체 몸체로 이루어져있다.

  상태 라인은 프로토콜 버전 필드, 상태 코드, 상태 메시지를 갖는다.

  `Connection : close` 는 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는데 사용한다.

  `Date` 는 HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다. (마지막으로 수정된 시간이 아니다!)

  `Server` 서버의 타입을 나타낸다.

  `Last-Modified` 는 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다. 캐시서버에서 객체의 캐싱에 매우 중요하다.

  `Content-Length`는 송신되는 객체의 바이트 수를 나타낸다.

  `Content-Type` 은 객체 몸체 내부의 객체가 HTML 텍스트인 것을 나타낸다.

* 상태 코드
  * 200 OK : 요청이 성공되었고 정보가 응답으로 보내졌다.
  
  * 301 Moved Permanently : 요청 객체가 영원히 이동되었다. 새로운 URL은 응답 메시지의 `Location:` 헤더에 나와있다. 클라이언트 소프트웨어는 자동으로 이 새로운 URL을 추출한다.
  
  * 400 Bad Request : 서버가 요청을 이해할 수 없다는 일반 오류 코드
  
  * 404 Not Found : 요청 문서가 서버에 존재하지 않는다.
  
  * 505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.

### 2.2.4 사용자와 서버 간의 상호작용 : 쿠키

* 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 원하므로 웹 사이트가 사용자를 확인하는 것이 바람직할 때가 있다.

  * HTTP는 쿠키(cookie)를 통해 사이트가 사용자를 추적할 수 있도록 한다.

* 쿠키 기술

  * HTTP 응답 메시지 쿠키 헤더라인
  
  * HTTP 요청 메시지 쿠키 헤더라인
  
  * 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
  
  * 웹 사이트의 백엔드 데이터 베이스
  
* 웹 사이트는 사용자의 정보는 모르지만 특정 쿠키를 갖는 사용자가 어느 페이지를, 어떤 순서로, 몇 시에 방문했는지 정확히 알 수 있다.

### 2.2.5 웹 캐싱

* 웹 캐시(Web cache) 혹은 프록시 서버(proxy server)

  * 원 출처의 웹 서버(origin Web server)를 대신하여 HTTP 요구를 충족시키는 네트워크 개체
  
  * 객체에 대한 각각의 브라우저 요청은 웹 캐시에 가장 먼저 보내진다.
    
    1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
    
    2. 웹 캐시는 객체의 사본이 자신에게 저장되어 있는지 확인한다. 만일 저장되어 있다면 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.
    
    3. 웹 캐시가 객체를 가지고 있지 않다면 원출처의 서버로 TCP 연결을 설정한다. 그리고 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 요청을 보낸다. 기점 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보낸다.
    
    4. 웹 캐시가 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보낸다.
  
  * 캐시는 서버이면서 동시에 클라이언트라는 점에 유의한다.
  [img]
  
  * 평균 객체의 크기가 1Mbit, 기관 브라우저로부터 기점 서버에 대한 평균 요청 비율이 초당 15로 가정, HTTP 메시지 요청이 무시할 만큼 작으므로 네트워크나 접속 회선에 어떤 트래픽도 발생시키지 않는다고 가정
  
  * 접속 회선의 인터넷 부분 라우터가 HTTP 요청을 전달하고 응답을 받을 때까지 평균 소요시간 2초로 가정 (인터넷 지연)
  
  * 총 응답 시간(브라우저의 요청으로 객체 수신까지 걸리는 시간) = LAN 지연 + 접속 지연 + 인터넷 지연
  ```
  * LAN의 트래픽 강도 = 15(요청/초) * 1(Mbit/요청) / 100Mbps = 0.15
  * 접속회선의 트래픽 강도 = 15(요청/초) * 1(Mbit/요청) / 15Mbps = 1
  ```
  
  * 접속회선에 의한 트래픽 강도를 낮춰야 한다.
    
    * 15 Mbps에서 100 Mbps로 접속률을 높이게 되면 총 응답 지연은 약 2초이지만 많은 비용이 발생한다.
    
    * 일반적으로 캐시의 적중 비율은 0.2~0.7이므로 약 0.4의 적중률을 가지는 웹 캐시를 설치한다고 가정
      
      * 요청의 40%는 즉시 만족되고 60%의 요청은 기점 서버에 의해서 해결 되어야 하지만 트래픽 강도가 1.0에서 0.6으로 감소된다.
      
      * 일반적으로 0.8 미만의 트래픽 강도는 작은 지연에 속한다.
      
      * 따라서 평균 지연은 `0.4*0.01 + 0.6*2.01 = 1.2` 가 된다.
      
      * 상대적으로 웹 캐시의 비용은 적은 편이다.
  
* 웹 캐시의 장점

  * 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다. 특히 클라이언트와 기점 서버 사이의 병목 대역폭이 클라이언트와 캐시 사이의 병목 대역폭에 비해 매우 작을 때 더욱 효과적이다.
  
  * 웹 캐시는 한 기관에서 인터넷으로 접속하는 링크 상의 웹 트래픽을 대폭으로 줄일 수 있다.
  
  * 콘텐츠 전송 네트워크(CDN, Content Distribution Network)

* 조건부 GET

  * 웹 캐시를 사용할 때 객체의 복사본이 새것이 아닐 수 있다는 문제가 발생한다.
  
  * 클라이언트에 캐시된 이후에 웹 서버에 있는 객체가 갱신되었을 수도 있다.
  
  * 조건부 GET (contitional GET) : HTTP는 모든 객체들이 최신의 것임을 확인하면서 캐싱하는 방식을 갖고 있다.
  
  * 조건부 GET은 서버에게 그 책체가 명시된 날짜 이후 수정된 경우에만 객체를 보낼 것을 요구한다.
